module src/lib

import effekt
import option
import set
import bytearray

// Lambda Calculus Abstract Syntax Tree (AST)
type Expr {
  Var(name: String);
  Abs(param: String, body: Expr);
  App(func: Expr, arg: Expr)
}

// Convert an expression into its string representation.
def lambdaToString(self: Expr): String = self match {
  case Var(name)        => name
  case Abs(param, body) => "(λ" ++ param ++ ". " ++ lambdaToString(body) ++ ")"
  case App(func, arg)   => "(" ++ lambdaToString(func) ++ " " ++ lambdaToString(arg) ++ ")"
}

// Generate a fresh variable name given a base name and a set of used names.
def freshVar(name: String, used: Set[String]): String = {
  var newName : String = name
  var counter : Int = 0
  while (used.contains(newName)) {
    counter = counter + 1
    // Convert the counter to a character (assuming ASCII digits)
    val stringCounter : Char = (counter + 48).toChar()
    newName = name ++ stringCounter.toString
  }
  newName
}

// Collect free variables in an expression.
// In an abstraction, the bound variable is removed from the free set.
def freeVars(expr: Expr): Set[String] = expr match {
  case Var(name) => singletonGeneric[String](name)
  case Abs(param, body) => difference(freeVars(body), singletonGeneric(param))
  case App(func, arg) => union(freeVars(func), freeVars(arg))
}

// Perform alpha conversion on an expression to avoid variable capture.
// It renames the bound variable of an abstraction to a fresh name.
def alphaConvert(expr: Expr, used: Set[String]): Expr = expr match {
  case Var(name) => expr
  case Abs(param, body) =>
    val newParam = freshVar(param, used)
    // Replace the bound variable with the new name in the body.
    Abs(newParam, substitute(body, param, Var(newParam)))
  case App(func, arg) =>
    App(alphaConvert(func, used), alphaConvert(arg, used))
}

// Substitute all free occurrences of variable 'x' with expression 'v' in self.
def substitute(self: Expr, x: String, v: Expr): Expr = self match {
  case Var(name) =>
    if (name == x) { v } else { self }
  case Abs(param, body) =>
    if (param == x) {
      // 'x' is bound here, so do not substitute inside.
      self
    } else {
      // To avoid capture, first alpha-convert the body using the union
      // of free variables in v and self.
      val usedNames = union(freeVars(v), freeVars(self))
      val newBody = alphaConvert(body, usedNames)
      Abs(param, substitute(newBody, x, v))
    }
  case App(func, arg) =>
    App(substitute(func, x, v), substitute(arg, x, v))
}

// Perform one step of β-reduction on an expression.
// When encountering an application of the form (λx. body) arg,
// reduce it to substitute(body, x, arg).
// If no reduction is possible, the expression is returned unchanged.
def reduce(expr: Expr): Expr = expr match {
  // β-reduction: (λx. body) arg  ==>  substitute(body, x, arg)
  case App(Abs(param, body), arg) =>
    substitute(body, param, arg)
  // Recursively try to reduce the function part first.
  case App(func, arg) =>
    val newFunc = reduce(func) 
    if (newFunc.equals(func)) {
      App(func, reduce(arg))
    } else {
      App(newFunc, arg)
    }
  // Reduce inside abstractions.
  case Abs(param, body) =>
    Abs(param, reduce(body))
  // Variables cannot be reduced.
  case _ => expr
}

// Evaluate an expression to normal form by repeatedly applying beta reduction.
def eval(expr: Expr): Expr = {
  val reduced = reduce(expr)
  if (reduced.equals(expr)) {
    expr
  } else {
    eval(reduced)
   }
}