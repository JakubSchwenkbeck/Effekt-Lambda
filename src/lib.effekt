module src/lib

import effekt
import option
import set
import bytearray
import src/lib/ast
import src/lib/vars



// Perform alpha conversion on an expression to avoid variable capture.
// It renames the bound variable of an abstraction to a fresh name.
def alphaConvert(expr: Expr, used: Set[String]): Expr = expr match {
  case Var(name) => expr
  case Abs(param, body) =>
    val newParam = freshVar(param, used)
    // Replace the bound variable with the new name in the body.
    Abs(newParam, substitute(body, param, Var(newParam)))
  case App(func, arg) =>
    App(alphaConvert(func, used), alphaConvert(arg, used))
}

// Substitute all free occurrences of variable 'x' with expression 'v' in self.
def substitute(self: Expr, x: String, v: Expr): Expr = self match {
  case Var(name) =>
    if (name == x) { v } else { self }
  case Abs(param, body) =>
    if (param == x) {
      // 'x' is bound here, so do not substitute inside.
      self
    } else {
      // To avoid capture, first alpha-convert the body using the union
      // of free variables in v and self.
      val usedNames = union(freeVars(v), freeVars(self))
      val newBody = alphaConvert(body, usedNames)
      Abs(param, substitute(newBody, x, v))
    }
  case App(func, arg) =>
    App(substitute(func, x, v), substitute(arg, x, v))
}

// Perform one step of β-reduction on an expression.
// When encountering an application of the form (λx. body) arg,
// reduce it to substitute(body, x, arg).
// If no reduction is possible, the expression is returned unchanged.
def reduce(expr: Expr): Expr = expr match {
  // β-reduction: (λx. body) arg  ==>  substitute(body, x, arg)
  case App(Abs(param, body), arg) =>
    substitute(body, param, arg)
  // Recursively try to reduce the function part first.
  case App(func, arg) =>
    val newFunc = reduce(func) 
    if (newFunc.equals(func)) {
      App(func, reduce(arg))
    } else {
      App(newFunc, arg)
    }
  // Reduce inside abstractions.
  case Abs(param, body) =>
    Abs(param, reduce(body))
  // Variables cannot be reduced.
  case _ => expr
}

// Evaluate an expression to normal form by repeatedly applying beta reduction.
def eval(expr: Expr): Expr = {
  val reduced = reduce(expr)
  if (reduced.equals(expr)) {
    expr
  } else {
    eval(reduced)
   }
}